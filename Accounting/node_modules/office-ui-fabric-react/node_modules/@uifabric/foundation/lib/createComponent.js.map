{"version":3,"file":"createComponent.js","sourceRoot":"../src/","sources":["createComponent.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { concatStyleSets, IStyleSet, ITheme } from '@uifabric/styling';\nimport { Customizations, CustomizerContext, ICustomizerContext } from '@uifabric/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n\nimport { IComponent, ICustomizationProps, IStyleableComponentProps, IStylesFunctionOrObject, IToken, IViewRenderer } from './IComponent';\nimport { IDefaultSlotProps, ISlotCreator } from './ISlots';\n\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call the view prop.\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n * State component is optional. If state is not provided, created component is essentially a functional stateless component.\n *\n * @param component - component Component options. See IComponent for more detail.\n */\nexport function createComponent<\n  TComponentProps,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps = TComponentProps,\n  TStatics = {}\n>(component: IComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TStatics>): React.StatelessComponent<TComponentProps> & TStatics {\n  const { factoryOptions = {} } = component;\n  const { defaultProp } = factoryOptions;\n\n  const result: React.StatelessComponent<TComponentProps> = (componentProps: TComponentProps) => {\n    return (\n      // TODO: createComponent is also affected by https://github.com/OfficeDev/office-ui-fabric-react/issues/6603\n      <CustomizerContext.Consumer>\n        {(context: ICustomizerContext) => {\n          // TODO: this next line is basically saying 'theme' prop will ALWAYS be available from getCustomizations\n          //        via ICustomizationProps cast. Is there mechanism that guarantees theme and other request fields will be defined?\n          //        is there a static init that guarantees theme will be provided?\n          //        what happens if createTheme/loadTheme is not called?\n          //        if so, convey through getCustomizations typing keying off fields. can we convey this\n          //          all the way from Customizations with something like { { K in fields }: object}? hmm\n          //        if not, how does existing \"theme!\" styles code work without risk of failing (assuming it doesn't fail)?\n          // For now cast return value as if theme is always available.\n          const settings: ICustomizationProps<TViewProps, TTokens, TStyleSet> = _getCustomizations(\n            component.displayName,\n            context,\n            component.fields\n          );\n\n          const renderView: IViewRenderer<TViewProps> = viewProps => {\n            // The approach here is to allow state components to provide only the props they care about, automatically\n            //    merging user props and state props together. This ensures all props are passed properly to view,\n            //    including children and styles.\n            // TODO: for full 'fields' support, 'rest' props from customizations need to pass onto view.\n            //        however, customized props like theme will break snapshots. how is styled not showing theme output in snapshots?\n            const mergedProps: TViewProps & IStyleableComponentProps<TViewProps, TTokens, TStyleSet> = viewProps\n              ? {\n                  ...(componentProps as any),\n                  ...(viewProps as any)\n                }\n              : componentProps;\n\n            const theme = mergedProps.theme || settings.theme;\n\n            const tokens = _resolveTokens(mergedProps, theme, component.tokens, settings.tokens, mergedProps.tokens);\n            const styles = _resolveStyles(mergedProps, theme, tokens, component.styles, settings.styles, mergedProps.styles);\n\n            const viewComponentProps: typeof mergedProps & IDefaultSlotProps<any> = {\n              ...(mergedProps as any),\n              styles,\n              tokens,\n              _defaultStyles: styles\n            };\n\n            return component.view(viewComponentProps);\n          };\n          return component.state ? <component.state {...componentProps} renderView={renderView} /> : renderView();\n        }}\n      </CustomizerContext.Consumer>\n    );\n  };\n\n  result.displayName = component.displayName;\n\n  // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memozing them on use in slots.tsx.\n  if (defaultProp) {\n    (result as ISlotCreator<TComponentProps>).create = createFactory(result, { defaultProp });\n  }\n\n  assign(result, component.statics);\n\n  // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n  return result as React.StatelessComponent<TComponentProps> & TStatics;\n}\n\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\nfunction _resolveStyles<TProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  props: TProps,\n  theme: ITheme,\n  tokens: TTokens,\n  ...allStyles: (IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined)[]\n): ReturnType<typeof concatStyleSets> {\n  return concatStyleSets(\n    ...allStyles.map((styles: IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined) =>\n      typeof styles === 'function' ? styles(props, theme, tokens) : styles\n    )\n  );\n}\n\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\nfunction _resolveTokens<TViewProps, TTokens>(\n  props: TViewProps,\n  theme: ITheme,\n  ...allTokens: (IToken<TViewProps, TTokens> | false | null | undefined)[]\n): TTokens {\n  const tokens = {};\n\n  for (let currentTokens of allTokens) {\n    if (currentTokens) {\n      currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens(props, theme, ...currentTokens);\n      }\n\n      assign(tokens, ...(currentTokens as any));\n    }\n  }\n\n  return tokens as TTokens;\n}\n\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\nfunction _getCustomizations<TViewProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  displayName: string,\n  context: ICustomizerContext,\n  fields?: string[]\n): ICustomizationProps<TViewProps, TTokens, TStyleSet> {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TOOD: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  const DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}\n"]}