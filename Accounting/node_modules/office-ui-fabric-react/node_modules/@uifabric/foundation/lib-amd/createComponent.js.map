{"version":3,"file":"createComponent.js","sourceRoot":"../src/","sources":["createComponent.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { concatStyleSets, IStyleSet, ITheme } from '@uifabric/styling';\nimport { Customizations, CustomizerContext, ICustomizerContext } from '@uifabric/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n\nimport { IComponent, ICustomizationProps, IStyleableComponentProps, IStylesFunctionOrObject, IToken, IViewRenderer } from './IComponent';\nimport { IDefaultSlotProps, ISlotCreator } from './ISlots';\n\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call the view prop.\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n * State component is optional. If state is not provided, created component is essentially a functional stateless component.\n *\n * @param component - component Component options. See IComponent for more detail.\n */\nexport function createComponent<\n  TComponentProps,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps = TComponentProps,\n  TStatics = {}\n>(component: IComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TStatics>): React.StatelessComponent<TComponentProps> & TStatics {\n  const { factoryOptions = {} } = component;\n  const { defaultProp } = factoryOptions;\n\n  const result: React.StatelessComponent<TComponentProps> = (componentProps: TComponentProps) => {\n    return (\n      // TODO: createComponent is also affected by https://github.com/OfficeDev/office-ui-fabric-react/issues/6603\n      <CustomizerContext.Consumer>\n        {(context: ICustomizerContext) => {\n          // TODO: this next line is basically saying 'theme' prop will ALWAYS be available from getCustomizations\n          //        via ICustomizationProps cast. Is there mechanism that guarantees theme and other request fields will be defined?\n          //        is there a static init that guarantees theme will be provided?\n          //        what happens if createTheme/loadTheme is not called?\n          //        if so, convey through getCustomizations typing keying off fields. can we convey this\n          //          all the way from Customizations with something like { { K in fields }: object}? hmm\n          //        if not, how does existing \"theme!\" styles code work without risk of failing (assuming it doesn't fail)?\n          // For now cast return value as if theme is always available.\n          const settings: ICustomizationProps<TViewProps, TTokens, TStyleSet> = _getCustomizations(\n            component.displayName,\n            context,\n            component.fields\n          );\n\n          const renderView: IViewRenderer<TViewProps> = viewProps => {\n            // The approach here is to allow state components to provide only the props they care about, automatically\n            //    merging user props and state props together. This ensures all props are passed properly to view,\n            //    including children and styles.\n            // TODO: for full 'fields' support, 'rest' props from customizations need to pass onto view.\n            //        however, customized props like theme will break snapshots. how is styled not showing theme output in snapshots?\n            const mergedProps: TViewProps & IStyleableComponentProps<TViewProps, TTokens, TStyleSet> = viewProps\n              ? {\n                  ...(componentProps as any),\n                  ...(viewProps as any)\n                }\n              : componentProps;\n\n            const theme = mergedProps.theme || settings.theme;\n\n            const tokens = _resolveTokens(mergedProps, theme, component.tokens, settings.tokens, mergedProps.tokens);\n            const styles = _resolveStyles(mergedProps, theme, tokens, component.styles, settings.styles, mergedProps.styles);\n\n            const viewComponentProps: typeof mergedProps & IDefaultSlotProps<any> = {\n              ...(mergedProps as any),\n              styles,\n              tokens,\n              _defaultStyles: styles\n            };\n\n            return component.view(viewComponentProps);\n          };\n          return component.state ? <component.state {...componentProps} renderView={renderView} /> : renderView();\n        }}\n      </CustomizerContext.Consumer>\n    );\n  };\n\n  result.displayName = component.displayName;\n\n  // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memozing them on use in slots.tsx.\n  if (defaultProp) {\n    (result as ISlotCreator<TComponentProps>).create = createFactory(result, { defaultProp });\n  }\n\n  assign(result, component.statics);\n\n  // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n  return result as React.StatelessComponent<TComponentProps> & TStatics;\n}\n\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\nfunction _resolveStyles<TProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  props: TProps,\n  theme: ITheme,\n  tokens: TTokens,\n  ...allStyles: (IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined)[]\n): ReturnType<typeof concatStyleSets> {\n  return concatStyleSets(\n    ...allStyles.map((styles: IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined) =>\n      typeof styles === 'function' ? styles(props, theme, tokens) : styles\n    )\n  );\n}\n\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\nfunction _resolveTokens<TViewProps, TTokens>(\n  props: TViewProps,\n  theme: ITheme,\n  ...allTokens: (IToken<TViewProps, TTokens> | false | null | undefined)[]\n): TTokens {\n  const tokens = {};\n\n  for (let currentTokens of allTokens) {\n    if (currentTokens) {\n      currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens(props, theme, ...currentTokens);\n      }\n\n      assign(tokens, ...(currentTokens as any));\n    }\n  }\n\n  return tokens as TTokens;\n}\n\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\nfunction _getCustomizations<TViewProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  displayName: string,\n  context: ICustomizerContext,\n  fields?: string[]\n): ICustomizationProps<TViewProps, TTokens, TStyleSet> {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TOOD: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  const DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}\n"]}